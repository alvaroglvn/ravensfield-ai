DATABASE ARCHITECTURE - The Ravensfield Collection
==================================================

Database: Turso (SQLite-compatible, edge-hosted)
ORM: Drizzle ORM (schema definition & migrations)
Connection: HTTP API via fetch (Metro/Expo compatible)


TABLES
------

1. ARTICLES (Primary content)
   - id            INTEGER  Primary key, auto-increment
   - slug          TEXT     Unique URL identifier
   - title         TEXT     Article headline
   - seo_description TEXT   Meta description for SEO
   - content       TEXT     Full article body
   - created_at    TEXT     Timestamp (default: CURRENT_TIMESTAMP)

2. ARTWORKS (One-to-one with articles)
   - id            INTEGER  Primary key, auto-increment
   - article_id    INTEGER  FK -> articles.id (unique, cascade delete)
   - title         TEXT     Artwork name
   - year          TEXT     Year of creation
   - type          TEXT     Category (painting, sculpture, photograph, etc.)
   - medium        TEXT     Materials/technique
   - artist        TEXT     Creator name
   - image_prompt  TEXT     AI prompt used for generation
   - image_url     TEXT     CDN URL of the generated image
   - created_at    TEXT     Timestamp

3. QUOTES (One-to-many with articles)
   - id            INTEGER  Primary key, auto-increment
   - article_id    INTEGER  FK -> articles.id (cascade delete)
   - content       TEXT     Quote text
   - author        TEXT     Attribution
   - created_at    TEXT     Timestamp


RELATIONSHIPS
-------------

  articles (1) -----> (1) artworks
      |
      +-------------> (N) quotes

- Each article has exactly ONE artwork (the featured piece)
- Each article can have MULTIPLE quotes
- Deleting an article cascades to its artwork and quotes


CONNECTION SETUP
----------------

The app uses Turso's HTTP pipeline API instead of the native libsql
client because Metro (Expo's bundler) cannot bundle native Node modules.

Flow:
  1. API route (e.g., feed+api.ts) calls executeQuery()
  2. executeQuery() sends POST to https://<db>.turso.io/v2/pipeline
  3. Response is parsed and mapped to typed objects

Environment variables required:
  - TURSO_DATABASE_URL  (libsql://... format, converted to https)
  - TURSO_AUTH_TOKEN    (JWT from Turso dashboard)


METRO + EXPO CAVEATS
--------------------

The standard @libsql/client package DOES NOT work with Expo/Metro because:

1. Native bindings issue
   @libsql/client tries to load platform-specific native modules like
   @libsql/darwin-arm64 (macOS), @libsql/linux-x64, etc. Metro cannot
   bundle these Node.js native addons.

2. The /web and /http imports don't help
   Even imports like @libsql/client/web or @libsql/client/http still
   pull in the hrana-client dependency which has the same bundling
   issues (hrana.openHttp is not a function error).

3. drizzle-orm/libsql/web also fails
   Drizzle's web driver internally depends on the same problematic
   packages.

SOLUTION: Raw HTTP API
   We bypass all libsql packages entirely and call Turso's HTTP API
   directly using fetch(). This works because:
   - fetch() is available in both Node.js and browser environments
   - No native dependencies to bundle
   - The v2/pipeline endpoint accepts SQL statements as JSON

The trade-off is we lose Drizzle's query builder in API routes and
must write raw SQL. However, Drizzle is still used for:
   - Schema definitions (src/db/schema.ts)
   - Migrations via drizzle-kit
   - Type generation

Metro config (metro.config.js) also includes resolver rules to return
empty modules for any @libsql/* or libsql imports, preventing Metro
from attempting to bundle them if they're accidentally imported.


FILE LOCATIONS
--------------

  src/db/
    index.ts     - Connection & executeQuery helper
    schema.ts    - Drizzle table definitions & relations

  src/app/api/
    feed+api.ts           - GET /api/feed (latest 5 articles)
    article/[slug]+api.ts - GET /api/article/:slug (single article)

  drizzle.config.ts - Drizzle Kit config for migrations
  metro.config.js   - Resolver rules to exclude libsql native modules
